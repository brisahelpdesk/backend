import { Injectable } from '@nestjs/common';
import { PersistenceService } from '../persistence/persistence.service';
import { IBaseRepository } from '../../interfaces/base-repository.interface';
import { Offering } from './offering.entity';
import { OfferingPrismaMapper } from './offering.mapper';

@Injectable()
export class OfferingRepository implements IBaseRepository<Offering> {
    constructor(private readonly persistence: PersistenceService) {}

    async create(data: Offering): Promise<Offering> {
        const created = await this.persistence.tb_offering.create({
            data: {
                // uuid is generated by DB by default
                internal_code: data.internalCode,
                name: data.name,
                is_physical: data.isPhysical,
                is_active: data.isActive,
                description: data.description,
                created_at: data.createdAt ?? new Date(),
                updated_at: data.updatedAt ?? new Date(),
                tb_offering_type: {
                    connect: { uuid: data.type.uuid },
                },
            },
            include: { tb_offering_type: true },
        });

        return OfferingPrismaMapper.toDomain(created);
    }

    async findAll(): Promise<Offering[]> {
        return this.findAllFiltered({});
    }

    async findAllFiltered(filters: {
        name?: string;
        isActive?: boolean;
        isPhysical?: boolean;
    }): Promise<Offering[]> {
        const where: any = {};
        if (filters.name) {
            where.name = { contains: filters.name, mode: 'insensitive' };
        }
        if (filters.isActive !== undefined) {
            where.is_active = filters.isActive;
        }
        if (filters.isPhysical !== undefined) {
            where.is_physical = filters.isPhysical;
        }

        const rows = await this.persistence.tb_offering.findMany({
            where,
            include: { tb_offering_type: true },
            orderBy: { created_at: 'desc' },
        });
        return rows.map(OfferingPrismaMapper.toDomain);
    }

    async findByUUID(uuid: string): Promise<Offering | null> {
        const row = await this.persistence.tb_offering.findUnique({
            where: { uuid },
            include: { tb_offering_type: true },
        });
        return row ? OfferingPrismaMapper.toDomain(row) : null;
    }

    async update(uuid: string, data: Partial<Offering>): Promise<Offering> {
        // CHECK: How will it work when uuid doesn't exist on the database?
        const updated = await this.persistence.tb_offering.update({
            where: { uuid },
            data: {
                internal_code: data.internalCode,
                name: data.name,
                is_physical: data.isPhysical,
                is_active: data.isActive,
                description: data.description,
                updated_at: data.updatedAt ?? new Date(),
                //CHECK: Is it going to work properly?
                ...(data.type?.uuid
                    ? { tb_offering_type: { connect: { uuid: data.type.uuid } } }
                    : {}),
            },
            include: { tb_offering_type: true },
        });
        return OfferingPrismaMapper.toDomain(updated);
    }

    async delete(uuid: string): Promise<Offering> {
        const deleted = await this.persistence.tb_offering.delete({
            where: { uuid },
            include: { tb_offering_type: true },
        });
        return OfferingPrismaMapper.toDomain(deleted);
    }
}